#include <stdio.h>

int main()
{
    // 대입 연산자 (=)
    // 연산자 기준 오른쪽 값을 왼쪽 메모리에 대입함


    // 산술 연산자
    // + 연산자
    // - 연산자
    // * 연산자
    // / 연산자 (정수를 나눌 때 정수 몫만 반환 -> 소수점 밑에는 버림)
    // % 연산자 (나머지만 반환, 기본적으로 정수 연산만 가능)


    // 부호 연산자
    // +3
    // -3


    // 복합 대입 연산자
    // +=
    // -=
    // *=
    // /=
    // %=


    // 증감 연산자
    // ++ (증가 연산자)
    // -- (감소 연산자)
    // 앞에 붙이면 먼저 실행하고, 뒤에 붙이면 뒤에서 실행
    // (ex - ++a(전위 증가 연산자), a++(후위 증가 연산자))


    // 관계 연산자
    // <, >
    // ==
    // <=, >=


    // 논리 연산자
    // && (and)
    // || (or)
    // ! (not)
    
    
    // 비트 연산자
    // & (비트 and 연산자, 피연산자가 2개, 참조연산자는 피연산자가 하나로 별개이다)
    // 

    // 5 & 10 -> 0
    // (5)  00000101
    // (10) 00001010
    //      00000000

    // 5 | 10 -> 15
    // (5)  00000101
    // (10) 00001010
    //      00001111

    // 5 ^ 10 (XOR) -> 15
    // (5)  00000101
    // (10) 00001010
    //      00001111


    // 비트 쉬프트 연산자
    // << (비트 쉬프트 레프트)
    // 모든 비트를 왼쪽으로 밈. 초과하는(오버플로) 비트는 사라짐
    printf("shift %d to te left by %d = %d\n", 5, 3, 5 << 3);
    // 5 << 3 -> 40
    // 00000101
    // 00001010 (1)
    // 00010100 (2)
    // 00101000 (3)

    // >> (비트 쉬프트 라이트)
    // 모든 비트를 오른쪽으로 밈. 초과하는(언더플로) 비트는 사라짐
    // 5 >> 2 -> 1
    // 00000101
    // 00000010 (1)
    // 00000001 (2)


    // ? : 삼항 연산자
    // ?의 왼쪽 조건이 참이면 ':'의 왼쪽결과, 거짓이면 ':'의 오른쪽 결과를 반환함

    // , : 콤마 연산자
    int commaResult = 0, a = 0, b = 0;
    commaResult = a = 3, b = 4;
    printf("commResult %d, a=%d, b=%d\n", commaResult, a, b);


    // sizeof() 연산자
    // 메모리 공간에서 소모하는 메모리 크기를 바이트 단위로 계산해서 반환하는 연산자
    // 자료형, 변수, 값 모두 인자로 가능


    // 연산자의 우선 순위
    // 단행 > 산술 > 관계 > 논리 > 대입 > 콤마 (왼쪽으로 갈수록 높음)

    
    // 형변환 연산지

    // 암시적 형변환
    // 프로그래머가 따로 지정하지 않아도 컴파일러에 의해서 자동으로 처리되는 형변환을
    // 암시적 형변환 / 자동 변환 이라고 함
    int num_int = 10;
    short num_short = 2;
    char num_char = 4;
    // 정수 연산 레지스터는 32bit, 실수 연산 레지스터는 64bit
    // 
    // short + char 를 했지만 연산을 하기 위해 레지스터에 데이터가 전달될 때
    // 정수형 연산 레지스터의 단위 크기만큼 자동으로 자료형이 int 형으로
    // 변환된 채로 연산을 하게 됨. (즉, short + char 를 하면 실제 int + int 를 수행함)
    // 이 때 short 또는 char 처럼 연산용 레지스터의 데이터 크기보다 작은 자료형이
    // 연산용 레지스터 단위 크기의 형태로 데이터 크기가  커지는 것을 '승격 (promotion)'이라고 함.
    // 이런 경우 따로 프로그래머가 int 형으로 바꿔주지 않아도 되는데, 이를 '암시적 형변환'이라고 함.
        printf("%f\n", num_short + num_char);

    // 오버플로우에 의한 암시적 형변환
    // float = double
        float num_float = 234431.2346346346346;
        double num_double = 23412.34346346346;
        printf("%lf", num_float);

    
    // 명시적 형변환
    // 수식 앞에 () 를 붙이고 () 안에 변환할 데이터형을 적어준다.

    return 0;
}



//연산자 해볼만한 거
// 1. 다양한 자료형끼리 연산 (암시적 형변환 복습)
// 2. 여태 배운 모든 자료형에 대해서 sizeof()로 크기 확인하기
// 3. 다양한 자료형끼리 연산한 것을 sizeof()로 크기 확인하기
// 4. 비트연산 결과를 출력하기 전에 계산해 보고

// ******* 암시적 형변환, 오버플러우 의한 거 *******